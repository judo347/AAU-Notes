# Physical Design

How the system is going to look in the end.

**Conceptual design**: Determining: Logic, Functions, Structure, Content.

**Physical design**: Physical realization of: Logic, Functions, Structure, Content.

The UI: "Everything in the system that people come in contact with."

- **Physically**, people interact by:
  - Pressing buttons, touching a screen, moving a mouse over a table, etc..
- **Perceptually**, people interact through:
  - What they can see, hear and feel.
- **Conceptually**, people need to:
  - Know what commands exits
  - Know that certain data is available
  - Know how to navigate
  - Be able to find details
  - Be able to gain an overview

Two often used types of GUI: commando prompt and windows explorer. You can do the same, but do it in different ways. Representation vs. commandos and syntax.

#### WIMP

- Windows
- Icons
  - Understandable, familiar, unambiguous, memorable, informative, few, distinct, attractive, legible, compact, coherent and extensible.
- Menus
  - Cascading (unfolds when you mouse over or click an element), pop-up, contextual.
- Pointers

## Widget guidelines

Radio buttons: the form is a circle and you can only pick one option.

Checkboxes: square and you can pick multiple.

Different widgets that we are familiar with: Toolbars, textbox, drop downs, date, textarea, password, tel, URL, etc..

#### Nielsens heuristics (revised)

1. Visibility of system status (Like i Word where you can see that caret blinking and shows where you are placed in the document + the toolbar shows what options are active.)
2. Match between system and real world (The better icons reflect the real world, the easier is it for the user to understand with the icon resembles. Like the icon for BOLD is marked with a bold B).
3. User control and freedom (Give the user control and freedom over the program. Could be shortcuts and such, that gives extra freedom and control)
4. Consistency and standards (Different interfaces within the same system should be consistent, like a filechooser looks the same in all programs.)
5. Error prevention (Should help the user make the correct decisions. Like underlining a word spelled wrong.)
6. Recognition rather than recall (The user should be able to see with they can do, and not have to remember what they can do. Display save icon instead of relying on they remembering that they can save)
7. Flexibility and efficiency of use (dunno)

#### Petrie and Powers' heuristics

- Physical presentation:
  1. Make text and interactive elements large and clear enough
  2. Make page layout clear
  3. Avoid short time-outs and display times
  4. Make key content and elements and changes to them salient
- Content
  5. Provide relevant and appropriate content
  6. Provide sufficient but not excessive content
  7. Provide clear terms, abbreviations, avoid jargon
- Information Architecture
  8. Provide clear, well-organized information structures
- Interactivity
  9. How and why?
  10. Clear labels and instructions
  11. avoid duplications/excessive effort by users
  12. Make input formats clear and easy
  13. Provide feedback on user actions and system progress
  14. Make the sequence of interaction logic
  15. Provide a logical and complete set of options
  16. Follow conventions for interaction
  17. Provide the interactive functionality users will need and expect
  18. Indicate if links go to an external site or another webpage
  19. Interactive and non-interactive elements should be clearly distinguished
  20. Group interactive elements clearly and logically
  21. Provide information error message and error recovery

